## Swift5 N x M 크기의 2차원 배열 생성 방법
<pre>
    let array: [[Int]] = Array(repeating: Array(repeating: 0, count: m), count: n)
</pre>

## Swift5 for문 거꾸로 순회하는 방법
<pre>
    1. 마지막 순서를 포함하지 않는 경우 - for i in stride(from: 5, to: 0, by: -1) // 5, 4, 3, 2, 1
    2. 마지막 순서를 포함하는 경우 - for i in stride(from: 5, through: 0, by: -1) // 5, 4, 3, 2, 1, 0
</pre>

## 컴퓨터를 공부하면서 반드시 숙지해야 할 것
<pre>
    1. 문제 해결이 목적, 컴퓨터 프로그래밍은 그 수단
    2. 문제해결은 컴퓨터라는 연산 장치로 사람이 빠르게 할 수 없는 연산 같은 것을 컴퓨터로 효율적이게 처리하는 것을 예로 들 수 있음
    3. 프로그래밍 언어란, 사람이 컴퓨터와 소통하기 위한 언어로, 각각의 목적에 따라 여러 종류의 언어가 존재
</pre>

## 프로그램의 실행 단계
<pre>
    1. 인간이 이해할 수 있는 고급 프로그래밍 언어 => 컴파일러 => 어셈블리어 => Binary(0101...) => 프로그램 실행
</pre>

## 변수와 자료형
<pre>
    1. 변수 : 컴퓨터에 데이터를 저장할 공간
    2. 자료형 : 컴퓨터에 저장할 데이터의 형태 : 정수/실수, 문자, 문자열 등
    3. 정수형 변수의 범위 : -21억 ~ 21억(-2^31 ~ 2^31 - 1)
</pre>

## 캐스팅의 개념
<pre>
    1. 같은 자료형 사이의 연산은 그 자료형 연산으로 취급
    2. 다른 자료형 사이의 연산은 더 큰 범위의 연산으로 취급
    3. 즉, 자료형을 임시로 바꾸는 것을 캐스팅이라고 함
</pre>

## 문제를 해결하기 전에 해야할 것
<pre>
    1. 해당 문제에 맞는 설계 후 프로그래밍을 진행해야 정확하고 실수없이 해결할 수 있음
</pre>

## 배열
<pre>
    1. 변수 여러개를 한 번에 선언할 수 있는 방법
    2. 장점 : 데이터에 대한 접근이 빠름, 변수를 일일히 선언하지 않아도 동일한 자료형의 변수를 여러개를 한 번에 저장할 수 있음
    3. 단점 : 데이터에 대한 삽입/삭제 연산이 느림, 정적인 크기 할당
</pre>

## 2차원 배열
<pre>
    1. 2차원 좌표평면과 유사
    2. 가로, 세로가 존재함
</pre>

## 완전 탐색에 대한 이해(Brute-Force Algorithm)
<pre>
    1. 문제 해결하는 방법이 여러가지가 있고, 흔히 사용하는 방법이 몇 가지가 존재함
    2. 그 중 가장 간단한 문제 해결 방법이 완전 탐색
    3. 가능한 모든 경우를 모두 시도해 보는 알고리즘
    4. 완전 탐색을 수행하기 위해서는 모든 경우가 무엇인지 파악하는 것이 중요함
    5. 문제를 접했을 때 가장 먼저 접근해봐야 하는 알고리즘 
</pre>

## 정렬(Sort)
<pre>
    1. 특정 기준을 적용하여 데이터를 나열하는 알고리즘
    2. 오름차순 정렬(갈수록 커지는 것)
    3. 내림차순 정렬(갈수록 작아지는 것)
</pre>

## 기본적인 정렬 알고리즘의 종류
### 선택정렬(Selection Sort)
<pre>
    1. 최솟값을 맨 앞으로 이동시킴(오름차순)
    2. 왼쪽은 정렬이 모두 되었다는 의미
    3. O(N^2)의 시간복잡도를 가짐
    
    for i in 0..<(N - 1) {
        var index: Int = i
        for j in (i + 1)..<N {
            if data[index] > data[j] {
                index = j
            }
        }
        
        let temp: Int = data[index]
        data[index] = data[i]
        data[i] = temp
    }
</pre>

### 삽입정렬(Insertion Sort)
<pre>
    1. 원소를 차례대로 정렬된 배열에 삽입시킴
    2. 왼쪽은 정렬이 모두 되었다는 의미
    3. O(N^2)의 시간복잡도를 가짐
    
    for i in 1...(N - 1) {
        for j in stride(from: i, to: 0, by: -1) {
            if data[j] < data[j - 1] {
                let temp: Int = data[j]
                data[j] = data[j - 1]
                data[j - 1] = temp
            }
        }
    }
</pre>

### 버블정렬(Bubble Sort)
<pre>
    1. 인접한 원소를 비교하여 큰 수를 뒤로 보냄
    2. 오른쪽은 정렬이 모두 되었다는 의미
    3. O(N^2)의 시간복잡도를 가짐
    
    for i in stride(from: N - 1, to: 0, by: - 1) {
        for j in 0...(i - 1) {
            if data[j] > data[j + 1] {
                let temp: Int = data[j]
                data[j] = data[j + 1]
                data[j + 1] = temp
            }
        }
    }
</pre>

## 시간 복잡도(Time Complexity)
<pre>
    1. 문제를 효율적으로 해결
    2. 똑같은 문제를 해결 하더라도 빠르게 해결하는 것이 중요
    3. 시간 복잡도를 계산 함으로써 프로그램을 직접 실행해보지 않더라도 얼마나 빠른지 대략적으로 알 수 있음
    4. O(1), O(N), O(N^2) ... 중 가장 영향력 있는 시간복잡도가 최악의 경우 시간 복잡도를 결정함(최고차항)
    5. 컴퓨터 사양마다 명령을 수행하는데 걸리는 시간은 다 다르지만 비슷하다고 가정 했을 때, 대략 1억번 연산을 수행하는데 1초가 걸림
</pre>

## 기본 정수론(Basic Number Theory)
<pre>
    1. 정수(Integer)의 성질을 연구하는 분야
    2. 가령, 약수와 배수
</pre>

### 약수(Divisor)
<pre>
    특정 정수를 나누어 떨어지게 하는 수
</pre>

### 소수(Prime Number)
<pre>
    약수가 1과 자기 자신 뿐인 정수
</pre>

### 에라토스테네스의 체
<pre>
    1. 소수를 구하는 알고리즘 중 하나
    2. 소수의 배수를 지워 나감으로써 2부터 특정 범위 내의 소수를 얻을 수 있음
    3. O(N log N)의 시간복잡도를 가짐
    4. 2부터 N까지 모든 숫자들 중 모든 소수를 구할 때 사용하면 빠르지만, 특정 수가 소수인지 아닌지 판별할 때는 제곱근 까지 나눠보는 것이 더 빠름 
</pre>

### 소인수 분해
<pre>
    1. 숫자 N을 소수의 곱으로 나타냄
    2. 2부터 시작해서 차례대로 전부 나누어봄(2로 나누어 지는 수는 이미 앞에서 나눌 수 있을 때 까지 다 나누었기 때문에 4로 나누어지지 않는 것이 가능함, 3과 6, 5와 10 마찬가지)
</pre>

### 유클리드 호제법
<pre>
    1. 공약수 : A의 약수 이면서 동시에 B의 약수인 수
    2. 공배수 : A의 배수 이면서 동시에 B의 배수인 수
    3. 최대공약수(GCD, Greatest Common Divisor) : A의 약수 이면서 동시에 B의 약수인 수 중 가장 큰 수
    4. 최소공배수(LCM, Least Common Multiple) : A의 배수 이면서 동시에 B의 배수인 수 중 가장 작은 수
    5. 유클리드 호제법 : 최대공약수를 구하기 위한 알고리즘
    
    func getGCD(_ a: Int, _ b: Int) -> Int {
        return a % b == 0 ? b : getGCD(b, a % b)
    }
}
</pre>

### 파스칼 삼각형
<pre>
    1. 왼쪽 오른쪽 각 대각선 위의 수를 합하여 자신을 결정하는 형태
    2. 조합과 관련이 있음
    3. 경우의 수 문제에서 숫자가 굉장히 큰 경우 활용할 수 있음. 가령, 20 C 10의 끝 3자리 수를 구하는 경우(파스칼 삼각형을 구성할 때, % 1000 연산 하면 됨)
    
    func getPascalTriangle() -> Void {
        let N: Int
        var pascal: [[Int]] = [N + 10][N + 10]
        pascal[0][0] = 1
        
        for i in 1...N {
            pascal[i][0] = 1
            pascal[i][i] = 1
            
            for j in 1..<i {
                pascal[i][j] = pascal[i - 1][j - 1] + pascal[i - 1][j]
            }
        }
    }
</pre>
