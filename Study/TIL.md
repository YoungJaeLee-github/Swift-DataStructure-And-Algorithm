## Swift5 N x M 크기의 2차원 배열 생성 방법
<pre>
    let array: [[Int]] = Array(repeating: Array(repeating: 0, count: m), count: n)
</pre>

## Swift5 for문 거꾸로 순회하는 방법
<pre>
    1. 마지막 순서를 포함하지 않는 경우 - for i in stride(from: 5, to: 0, by: -1) // 5, 4, 3, 2, 1
    2. 마지막 순서를 포함하는 경우 - for i in stride(from: 5, through: 0, by: -1) // 5, 4, 3, 2, 1, 0
</pre>

## 컴퓨터를 공부하면서 반드시 숙지해야 할 것
<pre>
    1. 문제 해결이 목적, 컴퓨터 프로그래밍은 그 수단
    2. 문제해결은 컴퓨터라는 연산 장치로 사람이 빠르게 할 수 없는 연산 같은 것을 컴퓨터로 효율적이게 처리하는 것을 예로 들 수 있음
    3. 프로그래밍 언어란, 사람이 컴퓨터와 소통하기 위한 언어로, 각각의 목적에 따라 여러 종류의 언어가 존재
</pre>

## 프로그램의 실행 단계
<pre>
    1. 인간이 이해할 수 있는 고급 프로그래밍 언어 => 컴파일러 => 어셈블리어 => Binary(0101...) => 프로그램 실행
</pre>

## 변수와 자료형
<pre>
    1. 변수 : 컴퓨터에 데이터를 저장할 공간
    2. 자료형 : 컴퓨터에 저장할 데이터의 형태 : 정수/실수, 문자, 문자열 등
    3. 정수형 변수의 범위 : -21억 ~ 21억(-2^31 ~ 2^31 - 1)
</pre>

## 캐스팅의 개념
<pre>
    1. 같은 자료형 사이의 연산은 그 자료형 연산으로 취급
    2. 다른 자료형 사이의 연산은 더 큰 범위의 연산으로 취급
    3. 즉, 자료형을 임시로 바꾸는 것을 캐스팅이라고 함
</pre>

## 문제를 해결하기 전에 해야할 것
<pre>
    1. 해당 문제에 맞는 설계 후 프로그래밍을 진행해야 정확하고 실수없이 해결할 수 있음
</pre>

## 배열
<pre>
    1. 변수 여러개를 한 번에 선언할 수 있는 방법
    2. 장점 : 데이터에 대한 접근이 빠름, 변수를 일일히 선언하지 않아도 동일한 자료형의 변수를 여러개를 한 번에 저장할 수 있음
    3. 단점 : 데이터에 대한 삽입/삭제 연산이 느림, 정적인 크기 할당
</pre>

## 2차원 배열
<pre>
    1. 2차원 좌표평면과 유사
    2. 가로, 세로가 존재함
</pre>

## 완전 탐색에 대한 이해(Brute-Force Algorithm)
<pre>
    1. 문제 해결하는 방법이 여러가지가 있고, 흔히 사용하는 방법이 몇 가지가 존재함
    2. 그 중 가장 간단한 문제 해결 방법이 완전 탐색
    3. 가능한 모든 경우를 모두 시도해 보는 알고리즘
    4. 완전 탐색을 수행하기 위해서는 모든 경우가 무엇인지 파악하는 것이 중요함
    5. 문제를 접했을 때 가장 먼저 접근해봐야 하는 알고리즘 
</pre>

## 정렬(Sort)
<pre>
    1. 특정 기준을 적용하여 데이터를 나열하는 알고리즘
    2. 오름차순 정렬(갈수록 커지는 것)
    3. 내림차순 정렬(갈수록 작아지는 것)
</pre>

## 기본적인 정렬 알고리즘의 종류
### 선택정렬(Selection Sort)
<pre>
    1. 최솟값을 맨 앞으로 이동시킴(오름차순)
    2. 왼쪽은 정렬이 모두 되었다는 의미
    3. O(N^2)의 시간복잡도를 가짐
    
    for i in 0..<(N - 1) {
        var index: Int = i
        for j in (i + 1)..<N {
            if data[index] > data[j] {
                index = j
            }
        }
        
        let temp: Int = data[index]
        data[index] = data[i]
        data[i] = temp
    }
</pre>

### 삽입정렬(Insertion Sort)
<pre>
    1. 원소를 차례대로 정렬된 배열에 삽입시킴
    2. 왼쪽은 정렬이 모두 되었다는 의미
    3. O(N^2)의 시간복잡도를 가짐
    
    for i in 1...(N - 1) {
        for j in stride(from: i, to: 0, by: -1) {
            if data[j] < data[j - 1] {
                let temp: Int = data[j]
                data[j] = data[j - 1]
                data[j - 1] = temp
            }
        }
    }
</pre>

### 버블정렬(Bubble Sort)
<pre>
    1. 인접한 원소를 비교하여 큰 수를 뒤로 보냄
    2. 오른쪽은 정렬이 모두 되었다는 의미
    3. O(N^2)의 시간복잡도를 가짐
    
    for i in stride(from: N - 1, to: 0, by: - 1) {
        for j in 0...(i - 1) {
            if data[j] > data[j + 1] {
                let temp: Int = data[j]
                data[j] = data[j + 1]
                data[j + 1] = temp
            }
        }
    }
</pre>

## 시간 복잡도(Time Complexity)
<pre>
    1. 문제를 효율적으로 해결
    2. 똑같은 문제를 해결 하더라도 빠르게 해결하는 것이 중요
    3. 시간 복잡도를 계산 함으로써 프로그램을 직접 실행해보지 않더라도 얼마나 빠른지 대략적으로 알 수 있음
    4. O(1), O(N), O(N^2) ... 중 가장 영향력 있는 시간복잡도가 최악의 경우 시간 복잡도를 결정함(최고차항)
    5. 컴퓨터 사양마다 명령을 수행하는데 걸리는 시간은 다 다르지만 비슷하다고 가정 했을 때, 대략 1억번 연산을 수행하는데 1초가 걸림
</pre>

## 기본 정수론(Basic Number Theory)
<pre>
    1. 정수(Integer)의 성질을 연구하는 분야
    2. 가령, 약수와 배수
</pre>

### 약수(Divisor)
<pre>
    특정 정수를 나누어 떨어지게 하는 수
</pre>

### 소수(Prime Number)
<pre>
    약수가 1과 자기 자신 뿐인 정수
</pre>

### 에라토스테네스의 체
<pre>
    1. 소수를 구하는 알고리즘 중 하나
    2. 소수의 배수를 지워 나감으로써 2부터 특정 범위 내의 소수를 얻을 수 있음
    3. O(N log N)의 시간복잡도를 가짐
    4. 2부터 N까지 모든 숫자들 중 모든 소수를 구할 때 사용하면 빠르지만, 특정 수가 소수인지 아닌지 판별할 때는 제곱근 까지 나눠보는 것이 더 빠름 
</pre>

### 소인수 분해
<pre>
    1. 숫자 N을 소수의 곱으로 나타냄
    2. 2부터 시작해서 차례대로 전부 나누어봄(2로 나누어 지는 수는 이미 앞에서 나눌 수 있을 때 까지 다 나누었기 때문에 4로 나누어지지 않는 것이 가능함, 3과 6, 5와 10 마찬가지)
</pre>

### 유클리드 호제법
<pre>
    1. 공약수 : A의 약수 이면서 동시에 B의 약수인 수
    2. 공배수 : A의 배수 이면서 동시에 B의 배수인 수
    3. 최대공약수(GCD, Greatest Common Divisor) : A의 약수 이면서 동시에 B의 약수인 수 중 가장 큰 수
    4. 최소공배수(LCM, Least Common Multiple) : A의 배수 이면서 동시에 B의 배수인 수 중 가장 작은 수
    5. 유클리드 호제법 : 최대공약수를 구하기 위한 알고리즘
    
    func getGCD(_ a: Int, _ b: Int) -> Int {
        return a % b == 0 ? b : getGCD(b, a % b)
    }
}
</pre>

### 파스칼 삼각형
<pre>
    1. 왼쪽 오른쪽 각 대각선 위의 수를 합하여 자신을 결정하는 형태
    2. 조합과 관련이 있음
    3. 경우의 수 문제에서 숫자가 굉장히 큰 경우 활용할 수 있음. 가령, 20 C 10의 끝 3자리 수를 구하는 경우(파스칼 삼각형을 구성할 때, % 1000 연산 하면 됨)
    
    func getPascalTriangle() -> Void {
        let N: Int
        var pascal: [[Int]] = [N + 10][N + 10]
        pascal[0][0] = 1
        
        for i in 1 ~ N {
            pascal[i][0] = 1
            pascal[i][i] = 1
            
            for j in 1 ~ (i - 1) {
                pascal[i][j] = pascal[i - 1][j - 1] + pascal[i - 1][j]
            }
        }
    }
</pre>

## 문자형 변수(Character)
<pre>
    오직 하나의 문자만 담을 수 있는 자료형
</pre>

### 아스키코드
<pre>
    1. 컴퓨터는 문자를 모르기 때문에 숫자로 인식함
    2. 출력할 때만 그 숫자에 대응되는 문자로 출력함
    3. 숫자에 대응되는 문자 정보가 담긴 표를 아스키코드 표라고 함
</pre>

## 문자열(String)
<pre>
    1. 문자만으로 이루어진 배열
    2. 여러 개의 문자를 저장할 수 있음
</pre>

## 함수(Function)
<pre>
    1. 수학에서 어떤 숫자가 들어왔을 때 처리를 해서 출력하는 것
    2. 값을 입력받아 특정 연산을 수행하여 결과를 반환하는 것
    3. Swift 기준 함수 문법
    func 함수이름 -> 반환타입 {
        구현체
        반환값
    }
    
    4. Java 기준 함수(메소드) 문법
    public (static) 반환타입 함수이름 {
        구현체
        반환값
    }
</pre>

### 스코프(Scope)
<pre>
    1. 변수는 선언된 블록 내에서만 접근할 수 있음
    2. 함수간 작업의 완벽한 분담을 위해 스코프가 존재함
</pre>

## 포인터(Pointer)
<pre>
    1. 값을 저장하는 것이 아닌, 값의 위치(메모리 주소)를 저장하는 변수
    2. 해당 주소가 가리키는 곳으로 접근하면 실제 저장되어 있는 값을 알 수 있음
    3. 작성한 코드가 컴퓨터 내부적으로 어떻게 동작하는지에 대한 원리는 반드시 파악하고 있어야 하기 때문에 포인터의 개념이 중요함
</pre>

### 메모리(Memory)
<pre>
    1. 자료의 저장단위 : 비트(Bit), 바이트(Byte), 킬로바이트(KB), 메가바이트(MB), 기가바이트(GB)...
    2. RAM(Random Access Memory) : 자료를 저장하기 위한 장치, 위치마다 접근하는데 걸리는 시간이 비슷하기 때문에 Random이라고 함
    3. PC의 운영체제가 우리가 흔히 알고 있는 64bit 운영체제, 32bit 운영체제라는 것은 메모리 하나의 주소의 크기가 64bit, 32bit라는 것
    4. 즉, 메모리의 주소 하나가 최대로 담을 수 있는 용량이 8Byte(64bit), 4Byte(32bit)라는 말과 동일함
    5. Big Endian, Little Endian : 컴퓨터가 값을 저장하는 순서, 높은 숫자 부터 저장하는 것이 Big Endian, 낮은 숫자부터 저장하는 것이 Little Endian
</pre>

### 운영체제(Operating System)
<pre>
    1. 정의 : 하드웨어를 제어하기 위한 소프트웨어(ex) Linux, MacOS, Windows, iOS, Android...)
</pre>

## Call By Value vs Call By Reference
<pre>
    1. call by value : 값에 의한 호출, 변수의 값을 복사해서 인자로 넘겨줌. 따라서 원본의 값이 변경되지 않음
    2. call by reference: 참조에 의한 호출, 변수의 주소를 인자로 넘겨줌. 따라서 원본의 값이 변경됨
</pre>

### Swift에서의 Array

<img width="490" alt="스크린샷 2022-03-12 16 16 04" src="https://user-images.githubusercontent.com/77099686/158008204-caa533b8-d10c-4e71-a0f3-dd3ca6fe67fb.png">
    
<pre>
    1. Swift에서 Array는 struct 즉, 값 타입이기 때문에 전달인자로 전달될 때 값이 복사돼서 넘어감
    2. Call By Value를 Call By Reference 처럼 사용할 수 있는 방법이 있지만, 권장하지 않음
    3. 단, 아래와 같이 정확한 목적이 있는 경우에는 inout 키워드와 &(주소)값을 넘김으로써 사용할 수도 있음
    
    func swap(_ a: inout Int, _ b: inout Int) -> Void {
        let temp: Int = a
        a = b
        b = a
    }
    
    func solution() -> Void {
        var a: Int = 5
        var b: Int = 10
        
        swap(&a, &b)
        
        print(a, b) // 10, 5
    }
    solution()
</pre>

## 재귀함수(Recursive Function)
<pre>
    1. 자기자신을 부르는 함수
    2. 재귀함수도 함수이기 때문에 값을 입력받아 특정 연산을 수행하여 결과를 반환함
    3. 귀납적 계산 방법을 따름
    4. 귀납적 계산법이란, f(x)를 구하기 위해 또 다시 f(x)를 활용함
    5. 귀납적 계산법은 계산하기 위해 자기자신을 사용하는 식과 멈춰야 하는 기저조건이 존재함
</pre>

### 수학적 귀납법
<pre>
    1. 명제 P(n)이 모든 자연수 n에 대하여 성립함을 보이는 것
    2. 증명 순서 : 1. P(1)이 참임을 보임, 2. P(k)가 성립한다고 가정한 후, P(k + 1)이 성립함을 보임, 3. 따라서 모든 자연수 n에 대하여 P(n)이 성립함
    3. 재귀함수가 정확한 값을 반환하는지 증명하기 위해 수학적 귀납법을 사용함
</pre>

### 재귀함수 디자인 절차
<pre>
    1. 먼저 문제 속에서 재귀적 패턴(자기자신을 사용하는 패턴)을 파악해야 함
    2. 함수의 역할을 말로서 정확하게 정의함
    3. 기저조건에서 함수가 제대로 동작함을 보임
    4. 함수가 제대로 동작한다고 가정하고 함수를 완성함
</pre>
