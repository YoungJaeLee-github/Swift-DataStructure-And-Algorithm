## Swift5 N x M 크기의 2차원 배열 생성 방법
<pre>
    let array: [[Int]] = Array(repeating: Array(repeating: 0, count: m), count: n)
</pre>

## Swift5 for문 거꾸로 순회하는 방법
<pre>
    1. 마지막 순서를 포함하지 않는 경우 - for i in stride(from: 5, to: 0, by: -1) // 5, 4, 3, 2, 1
    2. 마지막 순서를 포함하는 경우 - for i in stride(from: 5, through: 0, by: -1) // 5, 4, 3, 2, 1, 0
</pre>

## 컴퓨터를 공부하면서 반드시 숙지해야 할 것
<pre>
    1. 문제 해결이 목적, 컴퓨터 프로그래밍은 그 수단
    2. 문제해결은 컴퓨터라는 연산 장치로 사람이 빠르게 할 수 없는 연산 같은 것을 컴퓨터로 효율적이게 처리하는 것을 예로 들 수 있음
    3. 프로그래밍 언어란, 사람이 컴퓨터와 소통하기 위한 언어로, 각각의 목적에 따라 여러 종류의 언어가 존재
</pre>

## 프로그램의 실행 단계
<pre>
    1. 인간이 이해할 수 있는 고급 프로그래밍 언어 => 컴파일러 => 어셈블리어 => Binary(0101...) => 프로그램 실행
</pre>

## 변수와 자료형
<pre>
    1. 변수 : 컴퓨터에 데이터를 저장할 공간
    2. 자료형 : 컴퓨터에 저장할 데이터의 형태 : 정수/실수, 문자, 문자열 등
    3. 정수형 변수의 범위 : -21억 ~ 21억(-2^31 ~ 2^31 - 1)
</pre>

## 캐스팅의 개념
<pre>
    1. 같은 자료형 사이의 연산은 그 자료형 연산으로 취급
    2. 다른 자료형 사이의 연산은 더 큰 범위의 연산으로 취급
    3. 즉, 자료형을 임시로 바꾸는 것을 캐스팅이라고 함
</pre>

## 문제를 해결하기 전에 해야할 것
<pre>
    1. 해당 문제에 맞는 설계 후 프로그래밍을 진행해야 정확하고 실수없이 해결할 수 있음
</pre>

## 배열
<pre>
    1. 변수 여러개를 한 번에 선언할 수 있는 방법
    2. 장점 : 데이터에 대한 접근이 빠름, 변수를 일일히 선언하지 않아도 동일한 자료형의 변수를 여러개를 한 번에 저장할 수 있음
    3. 단점 : 데이터에 대한 삽입/삭제 연산이 느림, 정적인 크기 할당
</pre>

## 2차원 배열
<pre>
    1. 2차원 좌표평면과 유사
    2. 가로, 세로가 존재함
</pre>

## 완전 탐색에 대한 이해(Brute-Force Algorithm)
<pre>
    1. 문제 해결하는 방법이 여러가지가 있고, 흔히 사용하는 방법이 몇 가지가 존재함
    2. 그 중 가장 간단한 문제 해결 방법이 완전 탐색
    3. 가능한 모든 경우를 모두 시도해 보는 알고리즘
    4. 완전 탐색을 수행하기 위해서는 모든 경우가 무엇인지 파악하는 것이 중요함
    5. 문제를 접했을 때 가장 먼저 접근해봐야 하는 알고리즘 
</pre>

## 정렬(Sort)
<pre>
    1. 특정 기준을 적용하여 데이터를 나열하는 알고리즘
    2. 오름차순 정렬(갈수록 커지는 것)
    3. 내림차순 정렬(갈수록 작아지는 것)
</pre>

## 기본적인 정렬 알고리즘의 종류
### 선택정렬(Selection Sort)
<pre>
    1. 최솟값을 맨 앞으로 이동시킴(오름차순)
    2. 왼쪽은 정렬이 모두 되었다는 의미
    3. O(N^2)의 시간복잡도를 가짐
    
    ```
    for i in 0..<(N - 1) {
        var index: Int = i
        for j in (i + 1)..<N {
            if data[index] > data[j] {
                index = j
            }
        }
        
        let temp: Int = data[index]
        data[index] = data[i]
        data[i] = temp
    }
    ```
}
</pre>

### 삽입정렬(Insertion Sort)
<pre>
    1. 원소를 차례대로 정렬된 배열에 삽입시킴
    2. 왼쪽은 정렬이 모두 되었다는 의미
    3. O(N^2)의 시간복잡도를 가짐
    
    ```
    for i in 1..<N {
        for j in stride(from: i, to: 0, by: -1) {
            if data[j] < data[j - 1] {
                let temp: Int = data[j]
                data[j] = data[j - 1]
                data[j - 1] = temp
            }
        }
    }
    ```
</pre>

### 버블정렬(Bubble Sort)

<pre>
    1. 인접한 원소를 비교하여 큰 수를 뒤로 보냄
    2. 오른쪽은 정렬이 모두 되었다는 의미
    3. O(N^2)의 시간복잡도를 가짐
    
    ```
    for i in stride(from: N - 1, to: 0, by: - 1) {
        for j in 0..<i {
            if data[j] > data[j + 1] {
                let temp: Int = data[j]
                data[j] = data[j + 1]
                data[j + 1] = temp
            }
        }
    }
    ```
</pre>

## 시간 복잡도(Time Complexity)

<pre>
    1. 문제를 효율적으로 해결
    2. 똑같은 문제를 해결 하더라도 빠르게 해결하는 것이 중요
    3. 시간 복잡도를 계산 함으로써 프로그램을 직접 실행해보지 않더라도 얼마나 빠른지 대략적으로 알 수 있음
    4. O(1), O(N), O(N^2) ... 중 가장 영향력 있는 시간복잡도가 최악의 경우 시간 복잡도를 결정함(최고차항)
    5. 컴퓨터 사양마다 명령을 수행하는데 걸리는 시간은 다 다르지만 비슷하다고 가정 했을 때, 대략 1억번 연산을 수행하는데 1초가 걸림
</pre>
